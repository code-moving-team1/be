// src/sockets/rooms.ts
export const customerRoom = (customerId: number) => `customer:${customerId}`;
export const moverRoom = (moverId: number) => `mover:${moverId}`;

/**
 * 룸 네이밍 규칙
 * --------------------------------------------------------------------
 * - 개인 타깃 푸시(알림)를 위해 "역할:식별자" 형태의 문자열을 룸 이름으로 사용한다.
 *   예) customer:12, mover:34
 *
 * 왜 이렇게 하나?
 * - Socket.IO의 '룸(room)'은 특정 연결 집합을 의미한다.
 * - 같은 유저가 브라우저 여러 탭/디바이스에서 접속해도, 모두 같은 "개인 룸"에 join 시키면
 *   서버는 한 번의 emit으로 해당 유저의 모든 클라이언트에 동시 푸시할 수 있다.
 * - 역할(role)을 접두사로 두면 운영/디버깅 시 직관적이며, 권한/타깃 구분도 명확해진다.
 *
 * 주의할 점
 * - 룸 이름은 "서버에서만" 신뢰한다. 클라이언트가 임의로 조작할 수 없게
 *   반드시 서버 인증 미들웨어(verifySocketAuth)에서 파생된 userId/role로만 join 시키자.
 * - 문자열 포맷은 서버/클라 어디서든 동일하게 써야 한다.
 *   (emit 측과 join 측이 포맷 불일치하면 실시간 수신이 안 됨)
 *
 * 확장 아이디어
 * - 역할 전체 브로드캐스트: "role:customer" 같은 역할 룸을 추가로 운용할 수 있음
 * - 리소스 단위 구독: 예) "request:1234", "chat:777" 등 엔티티 단위 실시간 업데이트
 * - 세션 분리: 필요시 "user:{id}:session:{connId}"처럼 세션 단위로도 세분화 가능
 */

/*
운영/디버깅 팁
----------------------------------------------------------------------
- 서버 로그에서 socket.join(room) 호출 시 룸 이름을 찍어두면 문제 추적이 쉽다.
- 멀티 인스턴스(수평 확장)에서는 Redis 어댑터를 붙여야,
  다른 프로세스에 붙어 있는 소켓들도 동일 룸으로 인식되어 emit가 전달된다.
*/
